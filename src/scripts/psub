#!/bin/bash

# @file psub
# @brief Wrapper for qsub with simplified interface and other options to
# support integration in Portage scripts.
#
# Wrapper for qsub intended to do, by default, what we usually want, and to
# simplify options we often use.  This script is intended to contain all the
# local peculiarities of the clusters we use.  Other sites using Portage or
# PORTAGEshared may need to adapt this script to their own cluster environment.
# Look for "CUSTOMIZE HERE" below for spots where we expect you might need to
# adapt things.
#
# @author Eric Joanis / Samuel Larkin
#
# Traitement multilingue de textes / Multilingual Text Processing
# Tech. de l'information et des communications / Information and Communications Tech.
# Conseil national de recherches Canada / National Research Council Canada
# Copyright 2006 - 2016, Sa Majeste la Reine du Chef du Canada /
# Copyright 2006 - 2016, Her Majesty in Right of Canada

usage() {
   for msg in "$@"; do
      echo $msg >&2
   done
   cat <<==EOF== >&2

Usage: psub [options] <command line>

  Wrap <command line> into a PBS script and qsub it.
  Caveat: <command line> will be interpreted again in the resulting script,
  so quote or escape any quotes, dollar sign or backslash you need preserved.

Options:

  Balzac options:
  -#             use # CPUs on a node thus getting access to more memory.

  GPSC options:
  -cpus C        Specify the required number of cpus. [1]
  -mem M         Specify the required amount of memory.  By default, GB are
                 assumed but user can specify G for GB or M for MB. [6G]
  -gpu           Ask for a node with a GPU.
  -i RES_IMAGE   Change the container's image [\$ENV{PSUB_RES_IMAGE}]
  -pe ENVIRONMENT Change the parallel environment [dev]
  -pepp          Change parallel processes [1]
  -rt RUNTIME    Specify the job's run time in minutes [1440 (one day)]
                 Default can be changed by setting the enviornment variable
                 PSUB_OVERRIDE_DEFAULT_RUNTIME_MINUTES, e.g. for ten days:
                 export PSUB_OVERRIDE_DEFAULT_RUNTIME_MINUTES=\$((10*24*60))
  -c CELL        Specify the cell you want your jobs to run in [gpsc1.science.gc.ca]
                 Default can be changed by setting the enviornment variable.
                 export JOBCTL_CELL=gpsc2.science.gc.ca

  General options:
  -memmap SIZE   request SIZE GB extra virtual memory, to accomodate memory
                 mapped IO.  Balzac note: use a value less than or equal to the
                 total size of files you will open using memory mapped IO,
                 otherwise you risk bringing down a node. [0]
  -j J           use -j J if you intend to run J processes in the same job, each
                 needing C cpus, M RAM and SIZE GB of shared memory-mapped data.
                 Your job will have J*M+SIZE RAM and J*C cpus, but a ulimit of
                 M+SIZE VMEM and OMP_NUM_THREADS=C for each process. [1]
  Note:
  Scripts run by psub can find out the values of the -cpus, -mem, and -memmap
  options in environment variable PSUB_RESOURCE_OPTIONS, while the -j value can
  be found in PSUB_OPT_J.

  -h(elp)        print this help message
  -v(erbose)     print the qsub script before submitting it
  -N JOB_NAME    specify job name
  -e ERR_FILE    stderr destination
  -o OUT_FILE    stdout destination
  -join          join stderr with stdout in one file
  -noscript      don't write out the script
  -l RES=VAL[,RES2=VAL2[,...]]  resources for job (see man pbs_resources)
                 (separate multiple resources with commas, or repeat -l)
  -nodes PROPERTIES  properties the node should have; separate multiple
                 properties with colons, e.g., -nodes c2:blz0:big
                 (equivalent to -l nodes=PROPERTIES)
  -qsparams QSUB_PARAMETERS  additional qsub parameters
  -p PRIORITY    set the job priority; queued jobs with higher priority
                 should start first. 0 = normal, >0 = high, <0 = low.
                 Only use > 0 for short, urgent jobs. [0]
  -t ARRAY       See "qsub -t" in the TORQUE admin manual or man qsub
  -noc(luster)   Block recursive jobs: the job will think it's running on a
                 stand-alone, non-clustered machine.
  -n             "not really" (dump the PBS script, but don't submit it)
  -f             force submission even if errors are detected
  -I             enter interactive mode thus getting a prompt to a node
  -P PERIOD      Log memory usage of process tree every PERIOD minutes. [6]
  -require       Displays, without executing, how much vmem is required to run
                 the jobs (in GB on Balzac, in MB on the GPSC).
  -require-cpus  Displays, without executing, how many CPUs are required, if
                 specified explicitely; otherwise, has not output.

Further notes:

  -on Venus, to enable node borrowing, use "-l ckpt=1".
  -on Venus, to request a minimum amount of memory, use, e.g., "-l mem=1800m"
  -on Balzac, for temporary storage on local disks, use $TMPDIR.  Use
   "-nodes bigtmp" if you want lots of local temp storage.

==EOF==

   exit 1
}

error_exit() {
   echo -n "psub fatal error: " >&2
   for msg in "$@"; do
      echo $msg >&2
   done
   echo "Use -h for help." >&2
   exit 1
}

# arg_check_pos_int $value $arg_name exits with an error if $value does not
# represent a positive integer, using $arg_name to provide a meaningful error
# message.
arg_check_pos_int() {
   expr $1 + 0 &> /dev/null
   RC=$?
   if [ $RC != 0 -a $RC != 1 ] || [ $1 -le 0 ]; then
      error_exit "Invalid argument to $2 option: $1; positive integer expected."
   fi
}

arg_check() {
   if [ $2 -le $1 ]; then
      error_exit "Missing argument to $3 option."
   fi
}

# Convert the resquested memory to MegaBytes for the scheduler.
# Input: number with G or M suffix; no suffix means G
normalizeMemoryRequirement() {
   local MEM_AMOUNT=$1
   if [[ $MEM_AMOUNT ]]; then
      if [[ $MEM_AMOUNT =~ G$ ]]; then
         MEM_AMOUNT=${MEM_AMOUNT%%G};
         MEM_AMOUNT=$(($MEM_AMOUNT * 1024));
      elif [[ $MEM_AMOUNT =~ M$ ]]; then
         MEM_AMOUNT=${MEM_AMOUNT%%M};
      else
         MEM_AMOUNT=$(($MEM_AMOUNT * 1024));
      fi
   fi
   echo $MEM_AMOUNT
}

# Determine what cluster / cluster type we're on
if uname -n | egrep -q 'balzac|blz'; then
   NODES=notest
   BALZAC=1
elif uname -n | egrep -q 'venus|vns'; then
   VENUS=1
elif [[ `on-cluster.sh -type` == jobsub ]]; then
   GPSC=1
else
   # Set your cluster's flag here, to customize to your environment
   true
fi

### Balzac
# Set some virtual memory constant per cpu.
BALZAC_VMEM_LIMIT_GB_PER_CPU=7
BALZAC_VMEM_HARD_LIMIT_GB_PER_CPU=6
BALZAC_RAM_MB_PER_CPU=$((4*1024))

### GPSC
# Note: a be node has 100000M of ram and 16 cores thus ~6GB of ram per core
VMEM_LIMIT_MB_PER_CPU=6144   # 6 GB

PSUB_CMD=`echo "$0 $*" | perl -pe 'print "# " if $. > 1'`
CPU_COUNT=
VMEM_LIMIT_MB=
MEMORY_POLLING_DELAY=6
PRIORITY=
JOB_ARRAY=
OPT_J=1
REQUIRES_GPU=
NOCLUSTER_OPTION=

PSUB_RESOURCE_OPTIONS=

### GPSC
PARALLEL_ENVIRONMENT=dev
# NOTE, PE_PARALLEL_PROCESSES should always be 1.
PE_PARALLEL_PROCESSES=1
RUNTIME_MINUTES=${PSUB_OVERRIDE_DEFAULT_RUNTIME_MINUTES:-((24*60))} # default: one day in minutes (24 x 60 = 1440).

NODES=
while [ $# -gt 0 ]; do
   case "$1" in
   -h|-help)        usage;;
   -v|-verbose)     VERBOSE=1;;
   -N)              arg_check 1 $# $!;
                    NAME=$2;
                    shift;;
   -[1-9]|-[1-9][0-9])
                    # This is mostly just an message we systematically ignore - but leave it here
                    # commented out for when we work on optimizing frameworks that still use -#.
                    #if [[ $GPSC ]]; then
                    #   echo "Warning: -# is deprecated on gpsc: use -cpus and -mem instead." >&2;
                    #fi
                    CPU_COUNT=$((0 - $1))
                    VMEM_LIMIT_MB=$((VMEM_LIMIT_MB_PER_CPU * $((0 - $1))))
                    MEM_OPTION_MB=
                    [[ $DEBUG_PSUB_RES ]] && echo "$1 => CPU_COUNT=$CPU_COUNT"
                    PSUB_RESOURCE_OPTIONS="$PSUB_RESOURCE_OPTIONS $1";;
   -cpus)           arg_check 1 $# $!
                    CPU_COUNT=$2
                    PSUB_RESOURCE_OPTIONS="$PSUB_RESOURCE_OPTIONS $1 $2"
                    [[ $DEBUG_PSUB_RES ]] && echo "$1 $2 => CPU_COUNT=$CPU_COUNT"
                    shift;;
   -mem)            arg_check 1 $# $!
                    VMEM_LIMIT_MB=`normalizeMemoryRequirement "$2"`
                    PSUB_RESOURCE_OPTIONS="$PSUB_RESOURCE_OPTIONS $1 $2"
                    MEM_OPTION_MB=$VMEM_LIMIT_MB
                    shift;;
   -memmap)         arg_check 1 $# $!
                    arg_check_pos_int $2 $1
                    MEMMAP_GB=$2
                    PSUB_RESOURCE_OPTIONS="$PSUB_RESOURCE_OPTIONS $1 $2"
                    shift;;
   -j)              arg_check 1 $# $!
                    arg_check_pos_int $2 $1
                    OPT_J=$2
                    shift;;
   -gpu)            REQUIRES_GPU=1
                    PARALLEL_ENVIRONMENT="gpu"
                    RESOURCES="${RESOURCES:+$RESOURCES,}res_gpus=1"
                    ;;
   -I)              INTMODE=1;
                    NOSCRIPT=1;
                    [[ $CPU_COUNT ]] || CPU_COUNT=4;;
   -i)              arg_check 1 $# $!;
                    PSUB_RES_IMAGE=$2;
                    shift;;
   -pe)             arg_check 1 $# $!;
                    PARALLEL_ENVIRONMENT=$2;
                    shift;;
   -pepp)           arg_check 1 $# $!;
                    PE_PARALLEL_PROCESSES=$2;
                    shift;;
   -rt)             arg_check 1 $# $!;
                    RUNTIME_MINUTES=$2;
                    PSUB_RESOURCE_OPTIONS="$PSUB_RESOURCE_OPTIONS $1 $2"
                    shift;;
   -c)              arg_check 1 $# $!;
                    JOBCTL_CELL=$2;
                    shift;;
   -e)              arg_check 1 $# $!;
                    ERR_FILE=$2;
                    shift;;
   -o)              arg_check 1 $# $!;
                    OUT_FILE=$2;
                    shift;;
   -P)              arg_check 1 $# $!;
                    MEMORY_POLLING_DELAY=$2;
                    shift;;
   -noscript)       NOSCRIPT=1;;
   -l)              arg_check 1 $# $!;
                    RESOURCES="${RESOURCES:+$RESOURCES,}$2";
                    shift;;
   -nodes)          arg_check 1 $# $!;
                    NODES="${NODES:+$NODES,}$2";
                    shift;;
   -qsparams)       arg_check 1 $# $!;
                    QSPARAMS=$2;
                    shift;;
   -join)           QSPARAMS="-j y";;
   -noc|-nocluster) NOCLUSTER_OPTION="export PORTAGE_NOCLUSTER=1";;
   -p)              arg_check 1 $# $!;
                    PRIORITY="$1 $2";
                    shift;;
   -t)              arg_check 1 $# $!;
                    JOB_ARRAY="$1 $2";
                    shift;;
   -n)              NOT_REALLY=1;;
   -f)              FORCE=1;;
   -require)        REQUIREMENTS=1;;
   -require-cpus)   CPU_REQUIREMENTS=1;;
   --)              shift; break;;
   -*)              error_exit "Unknown options $1.";;
   *)               break;;
   esac
   shift
done

if [[ $BALZAC && $MEM_OPTION_MB ]]; then
   CALC_CPUS=$(( (MEM_OPTION_MB - 1) / BALZAC_RAM_MB_PER_CPU + 1 ))
   if [[ ! $CPU_COUNT || $CPU_COUNT -lt $CALC_CPUS ]]; then
      CPU_COUNT=$CALC_CPUS
      [[ $DEBUG_PSUB_RES ]] && echo "-mem ${MEM_OPTION_MB}M => CPU_COUNT=$CPU_COUNT"
   fi
fi

if [[ ! $CPU_COUNT ]]; then
   USING_DEFAULT_CPU_COUNT=1
   CPU_COUNT=1
fi

[[ $VMEM_LIMIT_MB ]] || VMEM_LIMIT_MB=$((VMEM_LIMIT_MB_PER_CPU * 1))  # 6GB

COMMAND="$*"

# Output the requirements of memory (in GB for Balzac, MB for GPSC) or cpus as
# a simple count.
function requirements {
   # Must be done before any qsub dependency
   if [[ $REQUIREMENTS ]]; then
      if [[ $BALZAC ]]; then
         VMEM_HARD_LIMIT_GB=$(($BALZAC_VMEM_HARD_LIMIT_GB_PER_CPU * $CPU_COUNT))
         # -memmap adds extra virtual memory
         if [[ $MEMMAP_GB ]]; then
            VMEM_HARD_LIMIT_GB=$((VMEM_HARD_LIMIT_GB + MEMMAP_GB))
         fi
         echo $VMEM_HARD_LIMIT_GB
      elif [[ $GPSC ]]; then
         echo $((VMEM_LIMIT_MB + MEMMAP_GB * 1024))
      else
         echo 0
      fi
      exit
   elif [[ $CPU_REQUIREMENTS ]]; then
      if [[ ! $USING_DEFAULT_CPU_COUNT ]]; then
         echo $CPU_COUNT
      fi
      exit
   fi
}


function script2Command {
   local PROG_NAME=$1
   local FORCE=$2

   # If the command is a script but doesn't have its x permission bit set,
   # call it with its interpreter
   if [ -f "$PROG_NAME" -a ! -x "$PROG_NAME" -a ! "$FORCE" ]; then
      if file $PROG_NAME | grep -q "script text"; then
         # file is a script
         local HASH_BANG_LINE=`head -1 $PROG_NAME`
         local INTERPRETER=${HASH_BANG_LINE/#\#\!}
         INTERPRETER=${INTERPRETER%% *}
         if which-test.sh "$INTERPRETER"; then
            echo Calling your script with "$INTERPRETER"
            COMMAND="$INTERPRETER $COMMAND"
         else
            echo "\"$PROG_NAME\" seems to be a $INTERPRETER script, but \"which\" can't find $INTERPRETER."
            echo "Make your script executable, fix it, or use -f to submit your command as is"
            exit 1
         fi
      else
         echo "\"$PROG_NAME\" is neither executable nor a script."
         echo "Use -f if you really mean to submit your command as is."
         exit 1
      fi
   fi
}


if [[ ! on-cluster.sh && ! $NOT_REALLY ]]; then
   error_exit "We don't seem to be running on a cluster."
fi

# Handle -require and -require-cpus now that all options have been processed
# psub exits in this function if -require or -require-cpus is specified.
requirements

# In interactive mode we need to reserve an entire node
if [[ $INTMODE ]]; then
   if [[ $BALZAC ]]; then
      # Don't allow part of a 2 CPU node, but do allow part of a fat node.
      if [ $CPU_COUNT = 3 ]; then
         CPU_COUNT=4
      elif [ $CPU_COUNT = 1 ]; then
         CPU_COUNT=2
      fi
   elif [[ $VENUS ]]; then
      CPU_COUNT=2
   elif [[ $GPSC ]]; then
      error_exit "-I is not supported (yet?) on the GPSC"
   else
      # CUSTOMIZE HERE if you want to tune psub to your own cluster.
      true
   fi
fi

if [[ ! $COMMAND && ! $INTMODE ]]; then
   error_exit "Missing command, nothing to run!"
fi

# -memmap is only implemented for Balzac, warn if used elsewhere
if [[ $MEMMAP_GB && ! $BALZAC && ! $GPSC ]]; then
   echo Warning: -memmap option only implemented for Balzac and GPSC at this point.
fi

if [ $INTMODE ]; then
   PROG_NAME=Interactive
else
   # Guess the executable program or script name
   PROG_NAME=`echo "$COMMAND" | perl -e '
      $_ = <>;
      chomp;
      # Use STDIN as the job name of the command seems empty
      $_ or $_ = "STDIN";
      @tokens = split;
      print $tokens[0];
   '`
fi

# The following call modifies COMMAND.
script2Command "$PROG_NAME" "$FORCE"

# Determine the default job name if -N is not specified on the command line.
if [[ ! $NAME ]]; then
   NAME=`basename $PROG_NAME`
fi

# Make sure $NAME is not longer that 15 characters, and starts with a letter
# GPSC Note: name length is not limited, but the name must still start with a letter
NAME=`echo $NAME | perl -e '
   $_ = <>;
   chomp;
   s/^([^a-z])/J$1/i;
   print substr($_, 0, 15);
'`

###############################################################################
###########################   GPSC SPECIFIC STUFF   ###########################
###############################################################################
# This function handles the stuff that is specific to the GPSC. (And maybe other
# clusters using jobsub?)
function write_gpsc_script {
   if [[ -z "$JOBCTL_CELL" ]];
   then
      # Covers the case where JOBCTL_CELL=X psub cmds
      export JOBCTL_CELL=$JOBCTL_CELL
   fi

   # PSUB_RES_IMAGE is set in profile.d/portage in order to have
   # control of the image at the project-level.
   local RES_IMAGE=${PSUB_RES_IMAGE:-nrc_all_default_centos-6.7-amd64_latest}

   TMPSCRIPT=/tmp/psub.`whoami`.`date +%s`.$$
   TMPSCRIPT=`mktemp $TMPSCRIPT.XXX` || error_exit "Cannot create temp file."
   trap "rm -f $TMPSCRIPT; exit" 0 2 3 13 14 15

   # Calculate the total required value of res_mem
   TOTAL_RES_MEM_MB=$((VMEM_LIMIT_MB * OPT_J + MEMMAP_GB * 1024))

   # The job's actual number of CPUs requested is $
   TOTAL_CPU_COUNT=$((OPT_J * CPU_COUNT))

   # Runtime is in seconds.
   local RUNTIME_SECONDS=$((RUNTIME_MINUTES * 60))

   local HERE=`pwd`
   ERR_FILE=${ERR_FILE:-$HERE}
   OUT_FILE=${OUT_FILE:-$HERE}

   # The CUDA driver allocates a lot of virtual memory.  According to the
   # internet it is something like ram + gpu_cores x some memory.  It is not
   # clear how to calculate how much virtual memory the CUDA driver will need
   # thus a first guestimate is 90G.
   [[ $REQUIRES_GPU ]] &&  VMEM_LIMIT_MB=$((90 * 1024 + VMEM_LIMIT_MB))

   # We set the ulimit -v 10MB lower than res_mem because it applies per process, not
   # globally. Those 10MB are for manager scripts and such
   # Known limitation: this won't catch memory problems when the user has multiple memory
   # consuming processes in one job. Those will still most likely get bus errors.
   # Also, the ulimit is not increased by -j, only by -mem and -memmap.
   VMEM_ULIMIT_KB=$(( ( VMEM_LIMIT_MB - 10 + MEMMAP_GB * 1024 ) * 1024))

   QSUB_CMD="jobsub ${JOBCTL_CELL:+-c $JOBCTL_CELL}"

cat <<==EOF== > $TMPSCRIPT
#!/bin/bash
#
#$ -N $NAME
#
# Combines STDERR & STDOUT to STDOUT
#####$ -j y

## Simply output the jobid.
#$ -terse

## Identifies the ability of a job to be rerun or not.
#$ -r no

## Run exactly one process under dev.
#$ -pe $PARALLEL_ENVIRONMENT  $PE_PARALLEL_PROCESSES
#$ -l res_cpus=$TOTAL_CPU_COUNT
#$ -l res_mem=$TOTAL_RES_MEM_MB
#$ -l h_rt=$RUNTIME_SECONDS
#$ -l res_image=$RES_IMAGE
#$ -o $OUT_FILE
#$ -e $ERR_FILE
#$ -S /bin/bash
#$ -M $USER
#$ -notify

## User provided from the command line.
## Job Array:
#$ $JOB_ARRAY
## Priority:
#$ $PRIORITY
## Resources:
#$ ${RESOURCES:+-l $RESOURCES}
## Nodes:
#$ ${NODES:+-l nodes=$NODES}
## Additional user-specified qsub parameters
#$ $QSPARAMS

# User's environment.
`env | egrep '^PORTAGE' | sed -e 's/^/export /'`
`env | egrep '^(LD_LIBRARY_PATH|PERL5LIB|PYTHONPATH|MANPATH|TMPDIR|PATH|MADA_HOME)=' | sed -e 's/^/export /'`
`env | egrep '^(LANG|LC_[A-Z]+)=' | sed -e 's/^/export /'`
`env | egrep '^(PSUB_NO_DEBUG|PSUB_OVERRIDE_DEFAULT_RUNTIME_MINUTES|JOBCTL_CELL)=' | sed -e 's/^/export /'`
$NOCLUSTER_OPTION

# Set the number of allowed openmp threads based on the number of cpus.
export OMP_NUM_THREADS=$CPU_COUNT

# Tell children what resources this job was submitted with
export PSUB_RESOURCE_OPTIONS="$PSUB_RESOURCE_OPTIONS"
export PSUB_OPT_J=$OPT_J

# TODO: redefine TMPDIR to use SSDs.

# TODO: we shouldn't source portage's profile !!?
#source /space/project/portage/main/profile

# On the GPSC, we set a ulimit -v to the memory requested, because otherwise the process
# just dies with a bus error when it exceeds its memory allocation.
ulimit -v $VMEM_ULIMIT_KB

######################
# DEBUGGING
if [[ ! \$PSUB_NO_DEBUG ]]; then
   echo DEBUGGING
   env
   whoami
   id
   pwd
   ls -l /space/project/portage
   ls -l /space/group/nrc_ict/pkgs/
   echo
   lscpu
   head -25 /proc/cpuinfo | grep "model name"
   echo END DEBUGGING
   echo; echo; echo; echo
fi >&2
# DEBUGGING

# Preserve the calling working directory
cd $HERE || { ! echo "Error: Cannot change directory to $HERE" >&2; exit; }

#process-memory-usage.pl $(($MEMORY_POLLING_DELAY*60)) \$\$ >&2 &

# Display the exact start time
echo ============ Starting job \$GECOSHEP_JOB_ID on \`date\` on node \`hostname\` >&2

# Trap kill signals
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGINT, aborting." >&2; exit 2' 2
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGQUIT, aborting." >&2; exit 3' 3
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGUSR1, aborting." >&2; exit 10' 10
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGUSR2, aborting." >&2; exit 12' 12
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGTERM, aborting." >&2; exit 15' 15

# User command
$COMMAND
RC=\$?

# Display the exact end time
echo ============ Finished job \$GECOSHEP_JOB_ID on \`date\` with rc=\$RC >&2

# Display resources used on stderr when the user command has completed
jobst -j \$GECOSHEP_JOB_ID >&2

# qsub command executed
# $QSUB_CMD $TMPSCRIPT

# original psub command given by user (with quotes and \\ removed)
# $PSUB_CMD
==EOF==
}


###############################################################################
#########################   LOGIC FOR QSUB CLUSTERS   #########################
###############################################################################
# The following is intended to work on clusters that use qsub, but was only
# tested on NRC's two such cluster, Balzac and Venus.
function write_qsub_script {
   if [[ $BALZAC ]]; then
      if [[ $CPU_COUNT -gt 1 || $OPT_J -gt 1 ]]; then
         PPN_NODES="1:ppn="$(($CPU_COUNT*$OPT_J))
      fi
      VMEM_LIMIT_GB=$(($BALZAC_VMEM_LIMIT_GB_PER_CPU * $CPU_COUNT * $OPT_J))
      VMEM_HARD_LIMIT_GB=$(($BALZAC_VMEM_HARD_LIMIT_GB_PER_CPU * $CPU_COUNT))
      # -memmap adds extra virtual memory
      if [[ $MEMMAP_GB ]]; then
         VMEM_LIMIT_GB=$((VMEM_LIMIT_GB + MEMMAP_GB))
         VMEM_HARD_LIMIT_GB=$((VMEM_HARD_LIMIT_GB + MEMMAP_GB))
      fi
      VMEM_HARD_LIMIT_KB=$((VMEM_HARD_LIMIT_GB * 1024 * 1024))

      if [ -n "$INTMODE" ]; then
         # We are in interactive mode thus we need to make sure we reserved the
         # entire node
         if [ $EXPLICIT_NODES ]; then
            true # the user provided an explicit -nodes specification, don't override
         elif [ $CPU_COUNT -gt 4 ]; then
            true # >4 CPUs can only go to a fat node, no need for explicit request
         elif [ $CPU_COUNT -gt 2 ]; then
            PPN_NODES="${PPN_NODES}:c4"
         else
            PPN_NODES="${PPN_NODES}:c2"
         fi
      fi
      if echo $RESOURCES | grep -q vmem=; then
         # User manually specified vmem, do not alter it
         true
      else
         if [[ $RESOURCES ]]; then
            RESOURCES="${RESOURCES},vmem=${VMEM_LIMIT_GB}g"
         else
            RESOURCES="vmem=${VMEM_LIMIT_GB}g"
         fi
      fi

      VMEM_LIMIT_SCRIPT_BLOCK="
# Memory use limited to $VMEM_HARD_LIMIT_GB GB to avoid system crashes.
# Use a larger -N value if this limit doesn't leave enough memory for your job,
# or -memmap if you are using memory-mapped IO.
ulimit -v $VMEM_HARD_LIMIT_KB"

      SOFTSTACK_LIMIT_SCRIPT_BLOCK="
# OpenMP requires lower Soft stack size in order to fit all threads' stack in
# memory.
ulimit -s 100000"

   else
      # CUSTOMIZE HERE if you want to tune psub to your own cluster.

      if [ $CPU_COUNT -gt 1 ]; then
         PPN_NODES="1:ppn=$CPU_COUNT"
      fi
   fi

   if [[ $PPN_NODES && $NODES ]]; then
      NODES="$PPN_NODES:$NODES"
   elif [[ $PPN_NODES ]]; then
      NODES="$PPN_NODES$NODES"
   fi

   if [[ $NODES ]]; then
      if [[ $RESOURCES =~ "(.*nodes=)(.*)" ]]; then
         RESOURCES=${BASH_REMATCH[1]}$NODES:${BASH_REMATCH[2]}
      elif [[ $RESOURCES ]]; then
         RESOURCES=$RESOURCES,nodes=$NODES
      else
         RESOURCES=nodes=$NODES
      fi
   fi

   # X forwarding doesn't work well with screen.
   if [[ $TERM != screen && $DISPLAY ]]; then
      X_DISPLAY=-X
   fi

   # qsub options we always use: -r n: not rerunable; -N $NAME: name the job
   QSUB_CMD="qsub -r n -N $NAME $PRIORITY $JOB_ARRAY $QSPARAMS"
   test -n "$RESOURCES" && QSUB_CMD="$QSUB_CMD -l$RESOURCES"
   if [[ $INTMODE ]]; then
      QSUB_CMD="$QSUB_CMD -I"
      test -n "$BALZAC" && QSUB_CMD="$QSUB_CMD $X_DISPLAY -d `pwd`"
      echo "Entering interactive mode."
      echo "Warning: you will get a fresh login environment.  Any variables set in the"
      echo "parent shell will not be propagated, only those in your login scripts."

      if [ $NOT_REALLY ]; then
         echo $QSUB_CMD
      else
         $QSUB_CMD
      fi
      exit
   fi

   test -n "$ERR_FILE" && QSUB_CMD="$QSUB_CMD -e $ERR_FILE"
   test -n "$OUT_FILE" && QSUB_CMD="$QSUB_CMD -o $OUT_FILE"

   if [ $BALZAC ]; then
      TMPDIR_SETUP='# On Balzac, $TMPDIR typically has 9GB, use -nodes bigtmp to get more space.'
   elif [ $VENUS ]; then
      TMPDIR_SETUP='# On Venus, $TMPDIR points to the PBS allocated scratch dir'
   else
      TMPDIR_SETUP='# Unknown TMPDIR configuration for this system'
   fi

   TMPSCRIPT=/tmp/psub.`whoami`.`date +%s`.$$
   TMPSCRIPT=`mktemp $TMPSCRIPT.XXX` || error_exit "Cannot create temp file."
   trap "rm -f $TMPSCRIPT; exit" 0 2 3 13 14 15

   cat <<==EOF== > $TMPSCRIPT
#!/bin/bash

# Preserve important parts of the calling environment
export PATH=\$PBS_O_PATH
`env | egrep '^PORTAGE' | sed -e 's/^/export /'`
`env | egrep '^(LD_LIBRARY_PATH|PERL5LIB|PYTHONPATH|MANPATH|MADA_HOME)=' | sed -e 's/^/export /'`
$NOCLUSTER_OPTION

# Preserve the calling working directory
cd \$PBS_O_WORKDIR || exit
$VMEM_LIMIT_SCRIPT_BLOCK
$SOFTSTACK_LIMIT_SCRIPT_BLOCK

# Set the number of allowed openmp threads based on the number of cpus.
export OMP_NUM_THREADS=$CPU_COUNT

# Tell children what resources this job was submitted with
export PSUB_RESOURCE_OPTIONS="$PSUB_RESOURCE_OPTIONS"
export PSUB_OPT_J=$OPT_J

# \$TMPDIR is scratch space on the local node; deleted after job ends.
$TMPDIR_SETUP

# Periodically monitor the memory usage of the process tree, since PBS does not
# do so reliably.
process-memory-usage.pl $(($MEMORY_POLLING_DELAY*60)) \$\$ >&2 &

# Display the exact start time
echo ============ Starting job \$PBS_JOBID on \`date\` on node \`hostname\` >&2

# Trap kill signals
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGINT, aborting." >&2; exit 2' 2
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGQUIT, aborting." >&2; exit 3' 3
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGUSR1, aborting." >&2; exit 10' 10
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGUSR2, aborting." >&2; exit 12' 12
trap 'echo "[\`date\` \`hostname\`] psub-generated script \`basename \$0\` caught SIGTERM, aborting." >&2; exit 15' 15

# User command
$COMMAND
RC=\$?

# Display the exact end time
echo ============ Finished job \$PBS_JOBID on \`date\` with rc=\$RC >&2

# Display resources used on stderr when the user command has completed
qstat -f \$PBS_JOBID | egrep '\b(Job Id|resources_used|comment)\b' >&2

# qsub command executed
# $QSUB_CMD $TMPSCRIPT

# original psub command given by user (with quotes and \\ removed)
# $PSUB_CMD
==EOF==
}

if [[ $GPSC ]]; then
   write_gpsc_script
else
   write_qsub_script
fi

# On some clusters, the script has to be executable
chmod +x $TMPSCRIPT

if [[ $VERBOSE ]]; then
   cat $TMPSCRIPT
   echo ""
fi

if [[ $NOT_REALLY ]]; then
   ls -l $TMPSCRIPT >&2
   cat $TMPSCRIPT
   echo ""
   exit
fi

JOBID=`$QSUB_CMD $TMPSCRIPT`
SAVE_JOBID=$JOBID
# To work around issues with jobsub directing error messages to stdout, we
# assume the last line of output is our jobname and strip preceding text.
JOBID=$(cat <<<"$JOBID" | tail -1)
JOBID=${JOBID%%[ ./]*}
[[ $SAVE_JOBID != $JOBID ]] && echo $SAVE_JOBID >&2
echo $JOBID

if [[ ! $NOSCRIPT ]]; then
   JOBSCRIPT=$NAME.j${JOBID:-0}
   cp $TMPSCRIPT $JOBSCRIPT
   # mktemp doesn't give any group permissions, so we need to set appropriate
   # group read/execute permissions on the jobfile: union of its original perms
   # and the group read/execute perms of the current directory.
   chmod $(printf %o $(( 0$(stat -c %a .) & 0050 | 0$(stat -c %a $JOBSCRIPT) )) ) $JOBSCRIPT
fi

[[ $BALZAC ]] && sleep 1 # give TORQUE a chance to breathe when many jobs are submitted

exit 0
